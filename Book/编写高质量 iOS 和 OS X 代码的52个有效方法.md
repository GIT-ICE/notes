第一章 熟悉Objective-C
-----------------

Objective-C 通过一套全新语法, 在C语言的基础上添加了面向对象的特性, 同时 OC 又添加了许多新的特性, 但是当并未完全理解这些特性时就会造成滥用某些特性, 导致写出来的代码难于维护且不易测试,还会隐藏一些奇葩的bug...

### 第 1 条: 了解Objecctive-C 语言的起源

*   使用消息结构的语言: 其运行时所执行的代码由 运行环境 来决定. 使用函数调用的语言: 其运行时所执行的代码由 编译器 决定. 编译器与运行环境 ? 
*   Objective-C 的关键在于运行期组件, 其关键工作都是由'运行期组件(runtime component)'来完成, 而非编译器来完成. (例如其内存管理方法). 运行期的好处在于通过更新运行期组件即可实现对程序性能的提升, 而 '编译期' 完成的语言则只能重新编译应用程序, 
*   C 中得内存分配问题整理 ? 为了更好的理解内存管理. 
*   C 的指针问题 ? 为了更好的理解指针类问题.

_Objective-C 为 C 语言添加了面向对象特性, 是其超集. Objective-C 使用动态绑定的消息结构,也就是说, 在运行式才会检查对象类型. 接受一条消息之后, 究竟应该执行何种代码, 由运行环境而非编译环境决定._

_理解 C 语言的核心概念有助于写好 Objective-C 程序. 尤其要掌握内存模型与指针._

**总结:** _对于OC的运行时与所谓的编译总是有些模糊, 对此需要好好看看, 而对于基于C的问题, 首先应该看看 内存管理的问题和指针问题, 如果时间允许: 最好看一本C语言的基础的书_

### 第 2 条: 在类的头文件中尽量少引入其他头文件

与 C 和 C++ 一样, Objective-C 也使用 头文件 (header file) 与实现文件 (implementation file) 来区分间隔代码.

*   import && include ： improt 相比于 OC 中的 include 解决了两个问题

1.  头文件重复引用的问题
2.  在 include 中循环引用会导致死循环的问题,而在 import 虽然不会再导致死循环,但是却会导致两个类中有一个无法被正确编译.

*   在实现文件中引入头文件可以缩短编译时间, 而在头文件中引入其他头文件则会增加编译时间, 为什么? 
    
    1.  使用 向前引用 @calss 可以解决两个类相互引用的问题
*   除非却有必要, 否则不要引入头文件, 一般来说,应在某个类的头文件中使用向前声明来提及别的类, 并在实现文件中引入那些类的头文件. 这样做可以尽量降低类之间的耦合(coupling).
    
*   有时也无法使用向前声明, 比如要声明某个类遵循一项协议. 这种情况下, 尽量把 '该类遵守某协议' 的这条声明移至 'class-continuation分类' 中. 如果不行的话,就把协议单独放在一个头文件中.然后将其引入. 总结: 我就想问: 头文件和实现文件在编译时的区别是什么?

### 第 3 条: 多用字面量语法, 少用与之等价的方法

*   使用字面量语法 (literal syntax, 语法糖) 可以缩减源代码长度, 使其更为易读.
*   暴露错误, 易于检查
*   应该使用字面量语法来创建字符串/ 数值/ 数组/ 字典. 与创建此类对象的常规方法相比, 这么做更加简明扼要.
*   应该通过取下标操作来访问数组下标或字典中的建所对应的元素.
*   用字面量语法创建数组或字典时,若值中有nil, 则会抛出异常,. 因此务必确保值里不含nil

### 第 4 条: 多用类型常量, 少用#define预处理指令

*   常量的定义应该从右至左解读. NSString *const kName = @"ICE"; 这就是一个常量, 而这个常量是指针,指向 NSString 对象 
*   const 修饰变量不可变, static 修饰局部变量 表示当前变量为全局变量, 修饰全局变量 表示当前变量的有效范围为当前文件内有效.关于const 和static 的详细解释可以看这里

1.  不要用预处理指令定义常量. 这样定义出来的常量不含类型信息, 编译器只会在编译前据此执行查找与替换操作.即使有人重新定义了常量值,编译器也不会产生警告信息,这将导致程序中得常量值不一致.
    
2.  在实现文件中使用 static const 来定义 `只在编译单元内可见的常量` (translation-unit-specific constant). 由于此类常量不在全局符号表中,所以无须为其名称加前缀.
    
3.  在头文件中使用 extern 来声明全局常量, 并在相关实现文件中定义其值. 这种常量要出现在全局符号中表中,所以其名称应该加以区隔, 通常用与之相关的类名做前缀.
    

### 第 5 条: 用枚举表示状态/ 选项/ 状态码

*   C++11 表准中允许指明用何种 底层数据类型 (underlying type) 来保存枚举类型的变量. 这样做的好处是可以向前声明枚举变量了. 指定底层数据类型所用的语法是: enum ICEConnectionState : NSInteger {/ ... /}; 
*   各种运算符特别是按位运算符?
*   写两个枚举的例子 
    
         typedef NS_OPTIONS(NSUInteger, UIRectCorner) {
            UIRectCornerTopLeft     = 1 << 0,
            UIRectCornerTopRight    = 1 << 1,
            UIRectCornerBottomLeft  = 1 << 2,
            UIRectCornerBottomRight = 1 << 3,
            UIRectCornerAllCorners  = ~0UL
          }; //特殊枚举, 采用 '按位操作符' 实现.
        
        
        
            /**
           *  消息来源
           */
          typedef NS_ENUM(NSInteger, MessageFrom) {
              /**
           *  自己发的
           */
          MessageFromSelf,
          /**
           *  接受到别人的
           */
          MessageFromOther,
          };
        
    

1. 应该用枚举状态来表示状态机的状态,传递给方法的选项以及状态码的值,给这些值起一个易懂的名字.

2. 如果把传递给某个方法的选项表示为枚举类型, 而多个选项又可同时使用, 那么就将各选项值 定义为2的幂 , 以便通过按位或操作将其组合起来.

3. 用 NS_ENUM 与 NSOPTIONS宏来定义枚举类型, 并指明其底层数据类型.这样做可以确保枚举是用开发者所选的底层数据类型实现出来的,而不会采用编译器所选的类型.

4. 在处理枚举类型的 switch 语句中不要实现 default 分支. 这样的话, 加入新枚举之后,编译器就会提示开发者: swithc 语句并未处理所有枚举.




第二章 对象、消息、 运行期
--------------

用 OC 等面向对象语言编程时, '对象'(object) 就是 '基本构造单元' (building block), 开发者可以通过对查能来存储并传递数据. 在对象之间传递数据并执行任务的过程就叫做 消息传递(Messaging). 若想编写出高效且易维护的代码, 就一定要熟悉这两个特性的工作原理.

Objective-C 运行期环境 (Objective-C runtime), 它提供了一些使得对象之间能够传递消息的重要函数.通过了解这些函数对理解运行时以及写出高质量的函数

### 第 六 条 理解 '属性' 这一概念

Objective-C 吧实例变量当做一种存储偏移量所用的特殊变量

应用程序二进制接口

synthesize 语法可以指定实例变量的名字

@dynamic 会告诉编译器: 不要自动创建属性所需要的实例变量, 也不要为其创建存取方法. 而且,在编译器访问属性的代码时, 即使编译器发现没有定义存取方法,也不会报错,他相信这些方法在运行期能找到.

属性的原子语义

unsaf_unretained && weak:

weak 声明为 weak 的指针,指针指向的地址一旦被释放, 这些指针都会被赋值为 nil, 这样的好处是能够有效地防止野指针, 而声明为 unsaf_unretained 的指针则不会释放.

指定存取方法

getter= 指定 获取方法的方法名.

setter= 指定 设置方法的方法名.

1.  可以用 @property 语法来定义对象中所封装的数据.
    
2.  通过 '特质' 来指定存储数据所需的正确语义.
    
3.  在设置属性所对应的实例变量时, 一定要遵从该属性所声明的语义.
    
4.  开发 iOS 程序时应该使用 nonatomic 属性, 因为 atomic 属性会严重影响性能,并且并不能完全保证
    

**总结: 对属性这一概念的理解还算清晰, 其基本用法也都知道, 但是对于更深的则不太懂了, 特别是对于为什么 Category 不能添加属性, 而这些再看了这一条之后了解到属性更深层次的原理则是基于 c++ 的,对此如果有机会则需要了解 C++ 的一些基础知识.**

### 第 七 条: 在对象内部尽量直接访问实例变量

1.  在对象内部读取数据时,应该直接通过实例变量来读, 而写入数据时, 则应该通过属性来写.
    
2.  在初始化方法及 dealloc 方法中,总应该直接通过实例变量来读写数据.
    
3.  有时候使用惰性初始化技术配置某分数据,这种情况下,需要通过属性来读取数据.
    

**总结: 在对象内部, 在不必要特殊化实例变量的存取方法时应该 直接通过实例变量来进行存取.而在必要的时候使用点语法.**

### 第 8 条: 理解 '对象等同性' 这一概念

等同性的概念:

    NSArray *arr1 = @[@"1"];
    NSArray *arr2 = [arr1 copy];
    此时:
     1. arr1 等于 arr2            √
     2. arr1 == arr2               ×
     3. [arr1 isEqual:arr2]      √
     4. arr1.hash == arr2.hash   √
    

hash 的原理 ?

按照 == 操作符对比时, 比较的仅仅是两个指针本身.(也就是说虽然指针可能不同但是对象可能相同.) NSObject 协议中有两个用于判断等同性的关键方法:

    (BOOL)isEqual:(id)object;
    -(NSUinteger)hash;
    

这两个方法的默认实现是: 当且仅当其 指针值 (pointer value) 完全相等时, 这两个对象才相等.

如果 'isEqual:'方法判断两个对象相等, 那么 hash 方法也必须返回同一个值,但是如果两个对象的 hash 方法返回的是同一个值, 那么 'isEqual:' 方法未必会认为两者相等.

1.  若想监测对象的等同性, 请提供 'isEqual:' 与 'has' 方法.
    
2.  形同的对象必须具有相同的哈希码, 但是两个哈希码相同的对象却未必相同.
    
3.  不要盲目的逐个监测每条属性, 而是应该依据具体需求来定制监测方案, 比如中国人, 只用看身份证.
    
4.  编写 hash 方法时, 应该使用计算速度快而且哈希码碰撞几率低的算法.
    

**总结 : 对于对象等同性应根据具体情况区分对待, 而不是以偏概全.**

### 第 9 条: 以 '类簇模式' 隐藏实现细节

在判断 '类簇' 类的类的时候, 不应该使用 \[NSArray class\] 检查类型的一致性, 而应该使用 'isKindOfClass':

    id maybeAnArray = / ... /;
    if(maybeAnArray == [NSArray class]){
    
      //Will never be hit
    }
    if([maybeAnArray isKindOfClass:[NSArray class]]){
    
      //Will be hit
    }
    

类簇模式可以吧实现细节隐藏在一套简单的公共接口后面

系统框架中经常使用类簇

从类簇的公共抽象基类中继承子类时要当心, 若有开发文档, 则应首先阅读.

**总结: 类簇模式 也就是工厂模式, 也是在使用中用的比较多的一种. 但是其对于 类型判断上的影响却一直没有注意道, 特别是对于一些系统类的使用也有着潜在的隐患, 而在继承 cocoa 库中的类簇时的注意事项也一直没有注意到.**

### 第 10 条: 在既有类中使用关联对象存放自定义数据

设置关联对象是用到的(key) 是个 不透明指针 (opaque pointer)(所指向的数据结构不局限于某种特定类型的指针.)

1.  可以通过 '关联对象' 机制来把两个对象连起来.
    
2.  定义关联对象时可指定内存管理语义, 用以模仿定义属性时所采用的 '拥有关系' 与 '非拥有关系'
    
3.  只有在其他做法不可行时才选用关联对象, 因为这种做法通常会引入难以查找的 bug.
    

**总结: 之前虽然有用对象关联,但是一直有一个疑问就是对 key 的定义 和 为什么不能总是使用不太理解. key 是泛型指针, 而不能随意用,其原因则在于内存管理语义, 其终究不是正经的方法, 而更深的则需要从内存理解.**

### 第 11 条: 理解 objc_msgSend 的作用

在对象上调用方法在 Objective-C 叫做 传递消息 ,消息有 名称(name) 或 选择子(selector), 可以接受参数, 而且还能有有返回值, 由于 Objective-C 是 C 的超集,所以要要想更好的理解 消息传递 最好先理解 C 语言的函数调用方式 静态绑定 (static binding),也就是在编译器就能决定运行时所调用的函数.

例如:

    import <stdio.h>
    void printHello(){
    
    printf("Hello, world !\n");
    }
    
    void printGoodbye(){
    
    printf("Goodbye, world!\\n");
    }
    
    //方式一:
    void doTheThing(int type){
    
    if(type == 0){
        printHello();
    }else{
        printfGoodbye();
    }
    }
    
    //方式二:
    void doTheThing(int type){
    void (*fnc)();
    if(type == 0){
    fun = printHello;
    }else{
    fun = printGoodbye
    }
    }
    

在方式一中, 如果不考虑 内联(inline), 那么编译器在编译代码的时候就已经知道 printHello 和 printGoodbye 这两个函数了, 于是会直接生成这些函数的指令.而函数地址实际上是硬编码在指令之中的.

而在方式二中, 就使用了 动态绑定 (dynamic binding) 因为所要调用的函数直到运行期才能确定,因为在这个例子中,只有一个函数调用指令,而带调用的函数地址无法硬编码在指令中, 而是要在运行期读取出来.

*   在 Objective-C 中如果向某个对象传递消息, 那就会使用动态绑定机制来决定需要调用的方法. 在底层,所有方法都是普通的 C 语言函数, 然而对象在收到消息之后, 究竟该调用哪个方法则完全取决于运行期决定.甚至可以在程序运行时改变. 这些特性使得 Objective-C 成为一门真正的动态语言.
    
    所以消息发送机制与运行时机制也就是 Objective-C 作为一门动态语言的核心所在.
    
*   objc\_msgSend 即消息传递机制的核心函数.其原型如下 void objc\_msgSend(id self, SEL cmd, ...) 这是一个 '参数可变的函数 (variadic function)', 能接受两个或者两个以上的参数. 这个函数能够处理大部分的消息, 但是其他 `边界情况 (edge case)` 则交由 Objective-C 环境中的另一些函数来处理, 例如:
    

1.  objc\_msgSend\_stret: 如果待发送的消息要返回结构体, 那么可交由此函数处理.
    
2.  objc\_msgSend\_fpret: 如果消息返回的是浮点数, 那么可交由此函数处理.
    
3.  objc_msgSendSuper: 如果要给超类发送消息, 例如 \[super message:parameter\]那么久交由此函数来处理.
    
4.  消息由接受者, 选择子及参数构成. 给某对象 '发送消息 (invoke a message) '也就相当于在该对象上调用 '调用方法'(call a method).
    
5.  发给某对象的全部消息都要由 "动态消息派发系统"(dynamic mesage dispatch system)来处理. 改系统会查出对应的方法. 并执行代码.
    

**总结:通过对比 OC 与 C 的函数调用机制, 可以大概的理解动态消息派发系统的原理, 从而引出 OC 的核心及动态消息派发系统, 与之相对应的就是 objc_msgSend 函数. 通过这个函数能够更好的理解 OC 的消息派发原理. 从中也更好的理解了 "OC 是 C 的超类" 这句话的含义.**

### 第 12 条: 理解消息转发机制

消息系统中的另一个重要概念 消息转发

当对象接收到无法解读的消息后, 就会启动 '消息转发' 机制. 消息转发分为两大阶段:

1.  第一阶段先征询接受者, 所属的类, 看其是否能动态添加方法, 以处理当前这 '未知的选择子' 这叫做 `动态方法解析`.
2.  第二阶段涉及 "完整的消息转发机制"

关于第一阶段的实现方法中:

1.  `动态方法解析` 可以看[这里](http://www.jianshu.com/p/7726a6e3ac6e). 备源接收者 可以模拟 多重继承 的某些特性

关于第二阶段 : 完整的消息转发

消息转发的用例也在于动态添加方法.

    1. 若对象无法响应某个选择子, 则进入消息转发流程. 
    
    2. 通过运行期的动态方法解析功能, 我们可以在需要用到某个方法时在将其加入类中. 
    
    3. 对戏那个可以把无法解读的某些选择子转交给其他对象来处理.
    
    4. 经过上述两步之后, 如果还是没有办法处理选择子, 那就启动完整的消息转发机制.
    

**总结: 通过对消息转发机制的理解, 大致理解了 carsh 的步骤, 也展示了另外一种对函数的动态处理思路, 不只是动态调用, 甚至可以通过这个方法, 动态添加方法,但是在实际使用使用中还没有用到过这个方法,所以对其理解并不深刻, 只能算是简单的理解了大致的流程,和用意, 但是具体用法并未深究. 之前在看一些教学视频时也有看到动态添加方法, 同样未能真正理解其用途.....**

### 第 13 条: 用 "方法调配技术" 调试 "黑盒方法"

方法列表: 类的方法列表会把选择子的名称映射到相关的方法实现上, 使得 '动态消息派发系统' 能够据此找到应该调用的方法.

方法调配 (覆写原有方法)

通过方法列表实现方法调配可以实现方法的交换, 添加, 修改等,而这些的实现则依赖于 Objective-C 运行时系统提供的几个用来操作这张表的方法:

    void method_exhangeImplementations(Method m1 , Method m2) //用于交换两个方法的实现
    Method Class_getInstanceMtehod(Class aClass, SEL aSelector) //从类中取出相关的方法
    

一些详细的操作用例可以看 这里

    1. 在运行期, 可以向类中新增或者替换选择子所对应的方法实现.
    
    2. 使用另一份实现来替换原有的方法实现, 这道工序叫做 '方法调配', 开发者经常用此技术向原有的实现中添加新的功能.
    
    3. 一般来说, 只有调试程序的时候, 才需要在运行期修改方法实现. 这种做法不易滥用.
    

**总结: 以前在看教学适配中曾看到过方法交换的实现, 但是当时只是大概理解操作的方法列表, 而通过这一些类的阅读, 对方法列表则有了更深刻的理解. 而所谓的方法调配, 则可以作为一个储配的技术, 用处或许很少....**

### 第 14 条: 理解 "类对象" 的用意

OC 对象的本质是什么?

    1. 每一个 Objective-C 对象实质上都是指向内存数据的指针.
    
    2. 每一个结构体的首个成员是 Class 类的变量, 改变量定义了所属的对象的类, 通常为 'isa' 指针.
    

在类继承体系中查询类型信息:

      1. isMemberOfClass:  能够判断出对象是否为某个特定的类的实例.
      2. isKindOfClass:  能够判断出对象是否为某类或其派生类的实例.
    
      NSMutableDictionary *dict = [NSMUtableDictionary new];
      [dict isMemberOfClass:[NSDictionary class]]; // < NO
      [dict isMemberOfClass:[NSMutableDictionary class]]; // < YES
      [dict isKindOfClass:[NSDictionary class]]; // < YES
      [dict isKindOfClass:[SNArray class]]; // < NO
    
    

    1. 每个实例都有一个指向 Class 对象的指针,用以表明其类型, 而这些 class 对象则构成了类的集成体系.
    
    2. 如果对象类型无法在编译器确定,那么就应该使用类型信息查询方法来探知
    
    3. 尽力使用类型信息查询方法来确定对象类型,而不要直接比较类对象, 因为某些对象可能实现了消息转发功能.
    

**总结: OC 中每一个的 isa 指针都指向其 类对象, 这个类对象确定了这个对象所属的类, 如此的布局信息保证了可以查询到任何 实例 的类型信息,其对于整个运行时系统的有着重要的作用, 但是具体是啥呢? 还不太清楚! 消息转发? 在运行期检视对象类型?**

OC 作为一个高度的动态语言, 采用运行时动态调用方法实现, 即运行时机制, 其中消息发送和及转发和相关的部分便是 OC 的核心所在, 而其对象定义有深刻的解释了消息发送和运行时机制的运行基础.



第三章 接口与 API 设计
--------------

让自己的代码更加规范!

### 第 15 条: 用前缀避免命名空间冲突

1.  选择与你的公司/应用程序/或者二者皆有关联之名称作为类名的前缀, 并在所有代码中均使用这一前缀.
    
2.  若自己开发的程序库中用到了第三方库,则应为其中的名称添加上前缀.
    

**总结: 在开发中, 我有将第三方的内容添加上第三方的前缀, 而一些控件的封装, 若是自己的封装则添加自己的前缀, 其他内容则用于项目相关的前缀进行统一, 以此充分避免,同时也便于区分.**

### 第 16 条: 提供 "全能初始化方法"

1.  在类中提供一个全能初始化方法, 并与文档中指明,其他初始化方法均应调用此初始化方法.
    
2.  若全能初始化方法与超类不同, 则需要覆写超类中的对应方法.
    
3.  如果超类的初始化方法不适合于子类, 那么应该覆写这个超类方法,并在其中输出异常.
    

**总结: 在平常的封装中, 总是会由于有没有必要对 不用的初始化方法进行覆写, 感觉有些事多余的, 但是如果不写确实会有隐藏的问题, 所以最终还是以规范为标准.**

### 第 17 条: 实现 description 方法

1.  实现 description 方法返回一个有意义的字符串, 用以描述改实例.
    
2.  若想在调试时打印出更详尽的对象描述信息, 则应该实现 debugDEscription 方法
    

### 第 18 条: 尽量使用不可变对象

1.  尽量创建不可变对象.
    
2.  若某属性尽可于对象内部修改, 则在 "class-continuation 分类" 中将其由 readonly 属性扩展为 readwrite 属性.
    
3.  不要把可变的 collection 作为属性公开, 而应提供相应相关方法, 以此修改对象中的可变 collection.
    

### 第 19 条: 使用清晰而协调的命名方式

1.  起名时应该遵从表针的 Objective-c 命名规范, 这样创建出来的接口更容易为开发者所理解.
    
2.  方法名要言简意赅, 从左至右读起来要像日常语句中的句子才好.
    
3.  方法名里不要使用缩略后的类型名称
    
4.  给方法起名时的第一要务就是确保其风格与自己的代码或所要集成的框架相符.
    

### 第 20 条: 为私有方法加前缀

Objective-C 没有办法将方法标为私有, 每个对象都可以响应任一消息, 而且可以在运行期监视某个对象所能直接响应的消息,

1.  给私有方法的名称前加上前缀. 这样可以很容易的将其同公共方法区分开
    
2.  不要用单一的一个下划线区分私有方法, 因为这种做法是预留给苹果公司用的.
    

**总结: 对于为私有方法加前缀, 其根本原因在于OC 不想 java 或者 C++一样可以明确的区分私有方法**

### 第 21 条: 理解 Objective-C 错误模型

抛出错误会导致内存泄露.

只有在处理严重错误的时候才抛出异常

使用 NSError 处理不太严重的错误.

1.  只有发生了可以使整个应用程序崩溃的严重错误时, 才应该使用异常.
    
2.  在错误不那么严重的情况下, 可以指派 '委托方法' 来处理错误, 也可以吧错误信息放在 NSError 对象里. 经由 '输出参数' 返回给调用者.
    

**总结: 在开发中并未经常使用 NSError....**

### 第 22 条: 理解 NSCopying 协议

在覆写 copy 是真正实现的是 copyWithZone: 方法.

浅拷贝/深拷贝

1.  若想令自己所写的对象具有拷贝功能, 则需要实现 NSCopying 协议.
    
2.  如果自定义的对象分为可变版本和不可变版本,那么就要同事实现 NSCopying 与 NSMutableCopy 协议.
    
3.  复制对象时需要决定采用浅拷贝还是深拷贝
    
4.  如果你所写的对象需要深拷贝, 那么可以考虑新增一个专门执行深拷贝的方法.
    

**总结: 本章讲了一些规范, 而这些在日常的开发中已有使用.**


第四章 协议与分类
---------

### 第 23 条: 通过委托与数据源协议进行对象间通信

代理的属性应该定义为 weak 而非 strong, 两者之间必须为非拥有关系(nonowing relationship).

对于必须实现的方法可以直接调用, 而非必须实习的方法则必须提前使用类型信息查询方法:

      if(_delegate respondsToSelector:@selector(networkFetcher:didReceiveData:)){
          [_delegate networkFethcer:self didReceiveDAta:data];
      }
    段位(bitfield) 数据类型:
    
      struct data {
          unsigned int fieldA : 8;
          unsigned int fieldB : 4;
          unsigned int fieldC : 2;
          unsigned int fieldD : 1;
      }
    

在结构体中, fieldA 位端将占用 8 个二进制位, fieldB 占有4个, fieldC 占有2个, 而 fieldD 则占有 1 个. 而 fieldD 则可以表示0 或者1 两个值.

1.  委托模式为对象提供了一套接口, 使其可由此将相关事件告知其他对象.
    
2.  将委托对象应该治藏的接口定义成协议, 在协议中把可能需要处理的事件定义成方法.
    
3.  当某对象需要从另一个对象获取数据时,可以使用委托模式.这种情况下,改模式亦成为 '数据源模式 (data source protocal)'
    
4.  若有必要,可实现含有段位的结构体,将委托对象是否能相应相关协议方法这一信息缓存至其中.
    

**总结: 在使用协议的过程中, 有些地方总感觉不如 block, 造成了代码的分散, 很不合理,于是有一段时间以至于基本不用协议, 而用 blcok 代替, 但是block 也并不是完美的, 事实证明,在改使用协议的地方发, 使用协议才是最好的解决办法.关于对在调用协议方法前进行类型信息检查,一直有一个错误的意识,即对任何协议方法尽心类型信息检查, 实际上这是没有必要的. 而只需要就选择性执行的方法进行查询就可以了.而使用结构体进行记录无疑是更好的方法.**

### 第 24 条: 将类的实现分散到便于管理的数个分类之中.

通过 Objective-C 的 分类机制,把类代码按逻辑划入几个分区中.

1.  使用分类机制把类的实现代码划分成易于管理的小块.
    
2.  将应该视为 '私有' 的方法归入明教 private 的分类中,以隐藏实现细节.
    

**总结: 在实际环境中其实除了使用分类实现一些系统类的特殊方法, 实际中很少使用.在之后的使用中应该多考虑是否可以以此方法实现代码的分割.**

### 第 25 条: 总是为第三方的分类名称加前缀

分类机制通常用于向无源码的既有类中新增功能.但是将分类的方法加入类中这一操作是在运行期系统加载分类时完成的.运行期会把分类中所实现的每个方法都加入类的方法列表中. 如果类中本来就由此方法,而分类又实现了一次,那么分类的方法会覆盖原来的那一份实现代码.

1.  向第三方类中添加分类时,总应该给其名称加上你专用的前缀
    
2.  向第三方类中添加分类时,总应该给其中的方法名加上你专用的前缀.
    

**总结: 在写分类是应该给方法名称添加前缀以避免方法的覆盖.原本以为在程序中命名难所说的只是名字不好想,其实更深的在于各种命名规范已然关系到了程序的 bug 问题...**

### 第 26 条: 勿在分类中声明属性

尽管从技术上说, 分类也可以声明谁属性,单这种做法还是要尽量避免.原因在于,除了 'class-continuation 分类'之外.其他分类都无法向类中增加实例变量.

分类机制应将其理解为一种手段,目标在于扩展类的功能,而非封住能数据.

关联对象能够解决在分类中不能合成实例变量的问题.

      statc const char *key = 'key';
      @implementation ExampleClass (ICEAdd)
      - (NSArray  *)friends {
          return objc_getAssociatedObject(self, key);
      }
    
      - (void)setFriends:(NSArray *)friends{
          objc_setAssociatedObject(self,key,friends,OBJC_ASSOCIATIONRETAIN_NONATOMIC);
      }
    
      @end
    

1.  把封装数据所用的全部属性都定义在主接口中.
    
2.  在 'class-continuation 分类'之外的其他分类中,可以定义存取方法,但是尽量不要定义属性.
    

**总结:在分类中不要声明属性,但是注意,并不是所有的属性.但是在有些时候必须添加属性的时候,关联对象也是不错的方法<慎用!!!>**

### 第 27 条: 使用 'class-continuation 分类'隐藏实现细节

可以定义方法和实例变量.<原因在于 稳固的 ABI这一机制>

在分类中定义私有的方法和属性可以用于隐藏实现细节.使代码更为安全.

编写 Objective-C++ 代码时, 'class-continuation 分类'也尤为有用.可以将 C++ 的编译延迟到 . m 文件中.

'class-continuation 分类'还有一种合理的用法,就是讲 public 接口中声明的 '只读'的属性扩展为 '可读写'

在 'class-continuation 分类'中声明所遵守的协议为私有的协议.

1.  通过 'class-continuation分类'向类中新增实例变量.
    
2.  如果某属性在主接口中声明为'只读',而类的内部又要用设置方法修改此属性,那么就在' class-continuation 分类'中将其扩展为'可读写'
    
3.  把私有方法的原型声明在' class-continuation 分类'里面
    
4.  若想使类所遵循的协议不为人所知,则可于 'class-continuation 分类'中声明.
    

**总结: 虽然一直在使用分类, 但是并没有完整的想过分类到底有多少种用法,有多少种意义,对于其强大更想知道其底层原理.**

### 第 28 条: 通过协议提供匿名对象

关于匿名对象的概念: OC 中的 匿名对象 与其他语言不同,在那些语言中,改词是指以内联形式创建的 无名类, 而此词在 OC 中则不是这个意思,在 OC 中 delegate 就是 匿名的.

1.  协议可在某种程度上提供匿名类型.具体的对象类型可以淡化成遵从某协议的 id 类型,协议里规定了对象所应实现的方法.
    
2.  使用匿名对象隐藏类型名称(或类名)
    
3.  如果具体类型不重要,重要的是对象能够响应(定义在协议里的)特定方法,那么可以使用匿名对象来表示.
    

**总结: 匿名对象, 是一种设计模式的提现.这一章讲解了 OC 中协议与分类在使用场景中的具体提现,与其真实意义.对于更好的理解这一常用的模式有了更好的理解.**